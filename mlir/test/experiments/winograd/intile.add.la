// ./bin/miopen-opt --convert-linalg-to-affine-loops ./intile.add.la

#map = affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d2, d3, d4, d5)>
#map1 = affine_map<(d0, d1, d2, d3, d4, d5) -> (d0, d1, d2*2 + d4, d3*2 + d5)>
module {
  func @main0(%arg0: memref<256x128x28x28xf32>, %arg1: memref<256x128x13x13x4x4xf32>) attributes {kernel} {
    linalg.generic {indexing_maps = [#map1, #map1, #map], iterator_types = ["parallel", "parallel", "parallel", "parallel", "parallel", "parallel"]} ins(%arg0, %arg0 : memref<256x128x28x28xf32>, memref<256x128x28x28xf32>) outs(%arg1 : memref<256x128x13x13x4x4xf32>) attrs =  {__inplace_operands_attr__ = ["true", "true", "true"]} {
    OPEN_FIND_MODE=1 MIOPEN_DEBUG_FIND_ONLY_SOLVER=ConvMlirIgemmFwdXdlops ^bb0(%arg3: f32, %arg4: f32, %arg5: f32):
      %0 = arith.addf %arg3, %arg4 : f32
      linalg.yield %0 : f32
    }
    return
  }
}